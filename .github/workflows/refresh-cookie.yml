name: Refresh IEEE Cookie

on:
  workflow_dispatch: # Allow manual trigger and API-triggered runs

jobs:
  refresh-cookie:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to push changes
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Playwright
        run: |
          pip install playwright
          playwright install chromium
          playwright install-deps chromium

      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 pandas openpyxl

      - name: Create login script
        run: |
          cat > /tmp/ieee_login.py << 'EOF'
          from playwright.sync_api import sync_playwright
          import json
          import time
          import sys
          import os

          IEEE_LOGIN_URL = "https://www.ieee.org/profile/public/createwebaccount/showSignIn.html"

          def login_and_get_cookie(username: str, password: str):
              with sync_playwright() as p:
                  # Launch browser with more realistic settings
                  browser = p.chromium.launch(
                      headless=True,
                      args=['--disable-blink-features=AutomationControlled']
                  )
                  context = browser.new_context(
                      user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                      viewport={'width': 1920, 'height': 1080},
                      locale='en-US',
                      timezone_id='America/New_York',
                      permissions=['geolocation']
                  )
                  page = context.new_page()
                  
                  # Remove webdriver property
                  page.add_init_script("""
                      Object.defineProperty(navigator, 'webdriver', {
                          get: () => undefined
                      });
                  """)
                  
                  # Set extra headers to look more like a real browser
                  page.set_extra_http_headers({
                      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                      'Accept-Language': 'en-US,en;q=0.9',
                      'Accept-Encoding': 'gzip, deflate, br',
                      'Connection': 'keep-alive',
                      'Upgrade-Insecure-Requests': '1',
                      'Sec-Fetch-Dest': 'document',
                      'Sec-Fetch-Mode': 'navigate',
                      'Sec-Fetch-Site': 'none',
                      'Cache-Control': 'max-age=0'
                  })
                  
                  try:
                      page.goto(IEEE_LOGIN_URL, wait_until='networkidle', timeout=60000)
                      time.sleep(3)
                      
                      # Debug: Print page title and URL
                      print(f"Page title: {page.title()}", file=sys.stderr)
                      print(f"Page URL: {page.url}", file=sys.stderr)
                      
                      # Check if request was rejected
                      page_title = page.title().lower()
                      page_url = page.url.lower()
                      page_content = page.content().lower()
                      
                      if "request rejected" in page_title or "request rejected" in page_content:
                          raise Exception("IEEE blocked the request - likely bot detection. May need to use different approach.")
                      
                      if "access denied" in page_content or "blocked" in page_content:
                          raise Exception("IEEE blocked access - bot detection triggered")
                      
                      # Try multiple selectors for email field (more comprehensive)
                      email_selectors = [
                          'input[type="email"]',
                          'input[name="email"]',
                          'input[name="username"]',
                          'input[name="userName"]',
                          'input[id*="email"]',
                          'input[id*="Email"]',
                          'input[id*="username"]',
                          'input[id*="userName"]',
                          'input[placeholder*="Email"]',
                          'input[placeholder*="email"]',
                          'input[placeholder*="Username"]',
                          '#email',
                          '#username',
                          '#userName',
                          'input.form-control',
                          'input[class*="email"]',
                          'input[class*="username"]',
                          'input[autocomplete="email"]',
                          'input[autocomplete="username"]'
                      ]
                      
                      email_filled = False
                      for selector in email_selectors:
                          try:
                              email_field = page.wait_for_selector(selector, timeout=3000, state='visible')
                              if email_field:
                                  email_field.click()
                                  email_field.fill(username)
                                  email_filled = True
                                  print(f"âœ“ Found email field with selector: {selector}", file=sys.stderr)
                                  break
                          except Exception as e:
                              continue
                      
                      if not email_filled:
                          # Last resort: try to find any input field and fill it
                          print("Trying fallback: finding any input field...", file=sys.stderr)
                          all_inputs = page.query_selector_all('input[type="text"], input[type="email"], input:not([type="hidden"]):not([type="submit"]):not([type="button"])')
                          if all_inputs:
                              first_input = all_inputs[0]
                              first_input.click()
                              first_input.fill(username)
                              email_filled = True
                              print("âœ“ Used fallback method to fill email", file=sys.stderr)
                      
                      if not email_filled:
                          # Save page HTML for debugging
                          page_content = page.content()
                          print(f"Page HTML snippet (first 2000 chars): {page_content[:2000]}", file=sys.stderr)
                          raise Exception("Could not find email field")
                      
                      time.sleep(1)
                      
                      # Try multiple selectors for password field
                      password_selectors = [
                          'input[type="password"]',
                          'input[name="password"]',
                          'input[id*="password"]',
                          '#password',
                          'input.form-control[type="password"]'
                      ]
                      
                      password_filled = False
                      for selector in password_selectors:
                          try:
                              password_field = page.wait_for_selector(selector, timeout=3000, state='visible')
                              if password_field:
                                  password_field.click()
                                  password_field.fill(password)
                                  password_filled = True
                                  print(f"âœ“ Found password field with selector: {selector}", file=sys.stderr)
                                  break
                          except Exception as e:
                              continue
                      
                      if not password_filled:
                          # Fallback: find password input by type
                          print("Trying fallback: finding password input...", file=sys.stderr)
                          password_inputs = page.query_selector_all('input[type="password"]')
                          if password_inputs:
                              password_inputs[0].click()
                              password_inputs[0].fill(password)
                              password_filled = True
                              print("âœ“ Used fallback method to fill password", file=sys.stderr)
                      
                      if not password_filled:
                          raise Exception("Could not find password field")
                      
                      time.sleep(1)
                      
                      # Try multiple selectors for submit button
                      submit_selectors = [
                          'button[type="submit"]',
                          'input[type="submit"]',
                          'button:has-text("Sign In")',
                          'button:has-text("Login")',
                          'button:has-text("Submit")',
                          'form button',
                          '.btn-primary',
                          '#submit'
                      ]
                      
                      submitted = False
                      for selector in submit_selectors:
                          try:
                              submit_button = page.query_selector(selector)
                              if submit_button:
                                  submit_button.click()
                                  submitted = True
                                  break
                          except:
                              continue
                      
                      if not submitted:
                          # Try pressing Enter
                          page.keyboard.press('Enter')
                      
                      # Wait for navigation/redirect
                      page.wait_for_load_state('networkidle', timeout=30000)
                      time.sleep(5)
                      
                      # Check for CAPTCHA
                      if 'captcha' in page.content().lower() or 'recaptcha' in page.content().lower():
                          raise Exception("CAPTCHA detected - manual intervention required")
                      
                      # Check for login errors
                      error_indicators = [
                          'invalid',
                          'incorrect',
                          'error',
                          'failed',
                          'wrong password',
                          'wrong email'
                      ]
                      
                      page_content_lower = page.content().lower()
                      for error in error_indicators:
                          if error in page_content_lower:
                              # Check if it's actually an error message
                              if any(indicator in page_content_lower for indicator in ['message', 'alert', 'warning']):
                                  raise Exception(f"Login failed: {error} detected")
                      
                      # Extract cookie
                      cookies = context.cookies()
                      cookie_value = None
                      
                      for cookie in cookies:
                          if cookie['name'] == 'PA.Global_Websession':
                              cookie_value = cookie['value']
                              break
                      
                      if not cookie_value:
                          raise Exception("PA.Global_Websession cookie not found after login")
                      
                      browser.close()
                      return cookie_value
                      
                  except Exception as e:
                      browser.close()
                      raise e

          if __name__ == "__main__":
              username = os.getenv('IEEE_USERNAME')
              password = os.getenv('IEEE_PASSWORD')
              
              if not username or not password:
                  print("Error: IEEE_USERNAME and IEEE_PASSWORD environment variables required", file=sys.stderr)
                  sys.exit(1)
              
              try:
                  print("Starting login process...", file=sys.stderr)
                  cookie = login_and_get_cookie(username, password)
                  if cookie:
                      print(cookie)
                      print("Login successful!", file=sys.stderr)
                  else:
                      print("Error: Cookie is None", file=sys.stderr)
                      sys.exit(1)
              except Exception as e:
                  print(f"Error: {str(e)}", file=sys.stderr)
                  import traceback
                  traceback.print_exc(file=sys.stderr)
                  sys.exit(1)
          EOF

      - name: Check secrets are set
        run: |
          if [ -z "${{ secrets.IEEE_USERNAME }}" ] || [ -z "${{ secrets.IEEE_PASSWORD }}" ]; then
            echo "âŒ Error: IEEE_USERNAME and IEEE_PASSWORD secrets must be set in GitHub repository settings"
            echo "Go to: Settings â†’ Secrets and variables â†’ Actions â†’ New repository secret"
            exit 1
          fi
          echo "âœ… Secrets are configured"

      - name: Login and get cookie
        env:
          IEEE_USERNAME: ${{ secrets.IEEE_USERNAME }}
          IEEE_PASSWORD: ${{ secrets.IEEE_PASSWORD }}
        run: |
          set +e  # Don't exit on error immediately
          echo "ðŸ” Logging into IEEE..."
          echo "Username: ${IEEE_USERNAME:0:5}*** (hidden)"
          
          # Run login script and capture all output
          python /tmp/ieee_login.py > cookie_output.txt 2>&1
          EXIT_CODE=$?
          
          # Always show output for debugging
          echo "=== Full Output (stdout + stderr) ==="
          cat cookie_output.txt || echo "(no output file)"
          echo "===================================="
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "âŒ Login script failed with exit code $EXIT_CODE"
            echo ""
            echo "Checking output files..."
            ls -la cookie_output.txt error_output.txt 2>&1 || true
            exit 1
          fi
          
          # Get cookie from stdout (should be last non-empty line)
          COOKIE=$(grep -v "^Starting\|^Login\|^Error:" cookie_output.txt | tail -n 1 | tr -d '\n\r')
          
          if [ -z "$COOKIE" ] || [ "${#COOKIE}" -lt 50 ]; then
            echo "âŒ Cookie is empty or too short (length: ${#COOKIE}). Login may have failed."
            echo "Full output:"
            cat cookie_output.txt
            exit 1
          fi
          
          echo "COOKIE=$COOKIE" >> $GITHUB_ENV
          echo "âœ… Cookie refreshed successfully (length: ${#COOKIE} chars)"
          echo "Cookie preview: ${COOKIE:0:50}..."

      - name: Update web app cookie
        run: |
          if [ -z "$COOKIE" ]; then
            echo "Error: Cookie not set"
            exit 1
          fi
          
          python3 << EOF
          import re
          
          cookie = "$COOKIE"
          file_path = "app/page.tsx"
          
          with open(file_path, 'r') as f:
              content = f.read()
          
          # Find and replace the defaultCookie value
          pattern = r"(const defaultCookie = ')[^']*(';)"
          replacement = r"\1" + cookie + r"\2"
          new_content = re.sub(pattern, replacement, content)
          
          if new_content == content:
              print("Warning: Cookie pattern not found in file")
              exit(1)
          
          with open(file_path, 'w') as f:
              f.write(new_content)
          
          print("âœ“ Web app cookie updated")
          EOF

      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add app/page.tsx
          if git diff --staged --quiet; then
            echo "â„¹ï¸  No changes to commit (cookie may be the same)"
          else
            git commit -m "Auto-refresh cookie via GitHub Actions [skip ci]"
            git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git HEAD:main
            echo "âœ… Changes committed and pushed"
          fi

      - name: Summary
        run: |
          echo "âœ… Cookie refresh completed successfully!"
          echo "ðŸ”„ Vercel will automatically redeploy with the new cookie"

